# 添付ファイルアップロード時の同時アクセス分析

## 質問

**filebaseならユーザーが極端な話1GBのファイルを添付した資料をアップロード中でも他のユーザーは別で作業して資料をアップロードする事は可能なの？**

## 実装コードからの分析

### 1. アップロード処理の流れ

#### DBベース（現在のワークスペース）

```154:231:src/app/api/materials/upload/route.ts
// 【重要】先にデータベースに保存（成功を確認してからファイルシステムに保存）
const db = getDatabase();

// 資料INSERT用の準備
const insertMaterial = db.prepare(`INSERT INTO materials ...`);

// リトライ処理（最大5回、指数バックオフ）
while (retryCount < maxRetries) {
  try {
    insertMaterial.run(...materialParams);
    dbSaveSuccess = true;
    break;
  } catch (err: any) {
    if (err.code === 'SQLITE_BUSY' && retryCount < maxRetries - 1) {
      retryCount++;
      const waitTime = 50 * retryCount; // 50ms, 100ms, 150ms, 200ms
      await new Promise(resolve => setTimeout(resolve, waitTime));
      continue;
    }
    throw err;
  }
}

// データベースへの保存が成功したので、ファイルシステムに保存
// ... 添付ファイルの保存処理 ...
```

**処理の流れ:**
1. **データベースに保存**（テーブル単位のロック）
2. **添付ファイルをファイルシステムに保存**（1GBのファイルを書き込み中）

#### Filebase（新規ワークスペース）

```156:193:C:\Users\cth-vmadmin01\Desktop\lms\k-shot-filebase\src\app\api\materials\upload\route.ts
// 【重要】先にデータベースに保存（成功を確認してからファイルシステムに保存）
try {
  await createRecord('materials', materialId, {
    id: materialId,
    uuid,
    title,
    // ... その他のフィールド
  });
  
  await addToIndexJson('materials', materialId);
  await addToIndex('materials', 'created_by', userId, materialId);
  await addToIndex('materials', 'is_published', '1', materialId);
  
  debug(MODULE_NAME, `ファイルベースDBに資料を追加成功: materialId=${materialId}`);
} catch (err) {
  error(MODULE_NAME, `ファイルベースDBへの保存に失敗: materialId=${materialId}`, err);
  throw err;
}

// データベースへの保存が成功したので、ファイルシステムに保存
// ... 添付ファイルの保存処理 ...
```

**処理の流れ:**
1. **ファイルベースDBに保存**（ファイル単位の操作、ロックなし）
2. **添付ファイルをファイルシステムに保存**（1GBのファイルを書き込み中）

### 2. `createRecord`の実装

```60:80:C:\Users\cth-vmadmin01\Desktop\lms\k-shot-filebase\src\shared\lib\file-db\record.ts
export async function createRecord<T = any>(
  tableName: string,
  recordId: string,
  data: T
): Promise<void> {
  const tempPath = getTempPath(tableName, recordId);
  const recordPath = getRecordPath(tableName, recordId);

  // ディレクトリが存在することを確認
  await ensureDirectoryExists(path.dirname(recordPath));

  // 一時ファイルに書き込み
  await fs.promises.writeFile(
    tempPath,
    JSON.stringify(data, null, 2),
    'utf-8'
  );

  // リネーム（アンチウイルス対策付き）
  await renameWithRetry(tempPath, recordPath);
}
```

**重要な点:**
- **ロックを使用していない**
- ファイル単位の操作（`material_${materialId}.json`）
- 他のレコードには影響しない

### 3. 添付ファイルの保存処理

両方の実装で、添付ファイルの保存は**データベースへの保存の後**に行われます：

```256:257:C:\Users\cth-vmadmin01\Desktop\lms\k-shot-filebase\src\app\api\materials\upload\route.ts
await writeFile(filePath, buffer);
debug(MODULE_NAME, `ファイル保存: ${filePath} ...`);
```

## 結論

### ✅ **Filebaseの場合: 可能**

**理由:**
1. **データベースへの保存は即座に完了**
   - `createRecord`はファイル単位の操作で、ロックを使用していない
   - 他のユーザーが別の資料をアップロードする際の`createRecord`はブロックされない

2. **添付ファイルの保存は独立している**
   - データベースへの保存の**後**に行われる
   - ファイルシステムへの書き込みは、データベース操作とは独立している
   - 1GBのファイルをアップロード中でも、他のユーザーは別の資料をアップロードできる

**動作例:**
```
ユーザーA: 1GBのファイルをアップロード中
  → createRecord('materials', 'material_001', ...) 完了（即座）
  → writeFile('1GB_file.bin', ...) 実行中（数分かかる）

ユーザーB: 別の資料をアップロード
  → createRecord('materials', 'material_002', ...) 実行可能（ブロックされない）
  → writeFile('small_file.pdf', ...) 実行可能
```

### ⚠️ **DBベースの場合: 制限あり**

**理由:**
1. **データベースへの保存時にロックが発生**
   - テーブル単位のロック（DELETEモード）
   - `SQLITE_BUSY`エラーが発生する可能性がある
   - リトライ機構で対応（最大5回、50ms, 100ms, 150ms, 200ms待機）

2. **他のユーザーのアップロードがブロックされる可能性**
   - ユーザーAがデータベースに保存中の場合、ユーザーBは待機する必要がある
   - ただし、データベースへの保存は短時間（数ミリ秒〜数秒）で完了するため、1GBのファイルをアップロード中でも、データベースへの保存は既に完了している

**動作例:**
```
ユーザーA: 1GBのファイルをアップロード中
  → INSERT INTO materials ... 完了（数ミリ秒〜数秒、テーブルロック）
  → writeFile('1GB_file.bin', ...) 実行中（数分かかる）

ユーザーB: 別の資料をアップロード
  → INSERT INTO materials ... 実行可能（ユーザーAのINSERTは既に完了）
  → ただし、ユーザーAのINSERT中にユーザーBがINSERTしようとすると、SQLITE_BUSYエラーが発生し、リトライが必要
```

## まとめ

| 項目 | DBベース | Filebase |
|------|----------|----------|
| **データベース保存時のロック** | テーブル単位 | ファイル単位（ロックなし） |
| **1GBファイルアップロード中の他ユーザー操作** | データベース保存は既に完了しているため、基本的に可能（ただし、同時にINSERTしようとするとSQLITE_BUSYが発生する可能性） | **完全に可能**（ファイル単位の操作のため、ブロックされない） |
| **同時アクセス性能** | ⭐⭐⭐ 中程度（テーブルロックの影響） | ⭐⭐⭐⭐⭐ 非常に良好（ファイル単位の操作） |

**結論:**
- **Filebase**: 1GBのファイルをアップロード中でも、他のユーザーは別の資料をアップロードできる（**完全に可能**）
- **DBベース**: データベースへの保存は既に完了しているため、基本的に可能だが、同時にINSERTしようとすると`SQLITE_BUSY`エラーが発生し、リトライが必要になる可能性がある

